part of 'core.dart.svg';

class _LevitReactiveCore {
  /// Whether to capture stack traces on state changes (expensive).
  static bool captureStackTrace = false;

  static LevitReactiveObserver? _proxy;

  // Cache for ultra-fast consecutive read skip
  static LevitReactiveObserver? _lastReportedObserver;
  static LxReactive? _lastReportedReactive;

  /// The active observer capturing dependencies.
  static LevitReactiveObserver? get proxy => _proxy;

  static set proxy(LevitReactiveObserver? value) {
    if (_proxy == value) return;
    _proxy = value;
    _lastReportedObserver = null;
    _lastReportedReactive = null;

    // In-lined _updateCoreState for set proxy
    if (value != null) {
      _coreState |= _stateHasProxy;
    } else {
      _coreState &= ~_stateHasProxy;
    }
    _fastPath = _coreState == 0;
  }

  static int _coreState = 0;
  static bool _fastPath = true;

  static const int _stateHasProxy = 1 << 0;
  static const int _stateAsyncDepth = 1 << 1;
  static const int _stateBatchDepth = 1 << 2;
  static const int _statePropagating = 1 << 3;

  /// Private helper used to update core state and fast path flag.
  /// In-lined in hot paths.
  static void _updateCoreState(int flag, bool active) {
    if (active) {
      _coreState |= flag;
    } else {
      _coreState &= ~flag;
    }
    _fastPath = _coreState == 0;
  }

  static final Object _batchEntriesKey = Object();

  static final List<LevitReactiveNotifier> _batchedNotifiers = [];

  static final List<LevitReactiveNotifier> _propagationQueue = [];

  static int _batchDepth = 0;

  /// Whether a batch operation is in progress.
  static bool get isBatching => _batchDepth > 0;

  /// Internal: Records a change during a batch.
  static void _recordBatchEntry(
      LxReactive reactive, LevitReactiveChange change) {
    // Skip zone lookup if no middlewares (fast path)
    if (!LevitReactiveMiddleware.hasBatchMiddlewares) return;

    final entries = Zone.current[_batchEntriesKey]
        as List<(LxReactive, LevitReactiveChange)>?;

    entries?.add((reactive, change));
  }

  // Removed _updateFastPath as it's now updated inline via bitmasks

  static void _flushGlobalBatch() {
    if (_batchedNotifiers.isEmpty) return;

    _batchDepth++;
    _coreState |= _stateBatchDepth;
    _fastPath = false;
    try {
      // Topological sort: Process sources (depth 0) before derived values
      // This prevents cascading re-notifications when a source changes
      // before its dependents have been notified.
      if (_batchedNotifiers.length > 16) {
        // Only sort for non-trivial batches
        _batchedNotifiers
            .sort((a, b) => a._graphDepth.compareTo(b._graphDepth));
      }

      // We use a while loop to handle re-entrant adds
      int processedCount = 0;
      while (processedCount < _batchedNotifiers.length) {
        final notifier = _batchedNotifiers[processedCount++];
        notifier._flags &= ~LevitReactiveNotifier._flagPendingSyncBatch;
        notifier._notifyListeners();
      }

      // Clear after all are processed.
      // Note: If new items are added during _notifyListeners, they append to list and loop continues.
      _batchedNotifiers.clear();
    } finally {
      // Safety: ensure cleared if exception (re-entrant exception?)
      // If exception occurs, we might leave flags execution.
      // But we should clear the list.
      if (_batchedNotifiers.isNotEmpty) {
        for (var n in _batchedNotifiers) {
          n._flags &= ~LevitReactiveNotifier._flagPendingSyncBatch;
        }
        _batchedNotifiers.clear();
      }
      _batchDepth--;
      if (_batchDepth == 0) {
        _coreState &= ~_stateBatchDepth;
        _fastPath = _coreState == 0;
      }
    }
  }

  /// Internal zone key for async tracking.
  static final Object asyncComputedTrackerZoneKey = Object();

  /// Internal zone key for async batching.
  static final Object _batchZoneKey = Object();

  static int _asyncZoneDepth = 0;

  static void _enterAsyncScope() {
    _asyncZoneDepth++;
    _coreState |= _stateAsyncDepth;
    _fastPath = false;
  }

  static void _exitAsyncScope() {
    _asyncZoneDepth--;
    if (_asyncZoneDepth == 0) {
      _coreState &= ~_stateAsyncDepth;
      _fastPath = _coreState == 0;
    }
  }

  /// Context data for the current listener registration operation.
  /// Used to associate listeners with high-level constructs (e.g., Widgets).
  static LxListenerContext? listenerContext;

  /// Executes [fn] with [context] set as the current listener context.
  static T runWithContext<T>(LxListenerContext context, T Function() fn) {
    final previousCheck = listenerContext;
    listenerContext = context;
    try {
      return fn();
    } finally {
      listenerContext = previousCheck;
    }
  }

  /// Executes [callback] in a synchronous batch.
  ///
  /// Changes are collected and passed to middleware hooks.
  /// Returns the result of [callback], or throws if a middleware cancels.
  static R batch<R>(R Function() callback) {
    if (!LevitReactiveMiddleware.hasBatchMiddlewares) {
      _batchDepth++;
      _coreState |= _stateBatchDepth;
      _fastPath = false;
      try {
        return callback();
      } finally {
        _batchDepth--;
        if (_batchDepth == 0) {
          _coreState &= ~_stateBatchDepth;
          _fastPath = _coreState == 0;
          _flushGlobalBatch();
        }
      }
    }

    // Wrapped path: collect changes for middleware
    final entries = <(LxReactive, LevitReactiveChange)>[];
    final batchChange = LevitReactiveBatch(entries);

    dynamic coreExecution() {
      _batchDepth++;
      _coreState |= _stateBatchDepth;
      _fastPath = false;
      try {
        return runZoned(
          callback,
          zoneValues: {_batchEntriesKey: entries},
        );
      } finally {
        _batchDepth--;
        if (_batchDepth == 0) {
          _coreState &= ~_stateBatchDepth;
          _fastPath = _coreState == 0;
          _flushGlobalBatch();
        }
      }
    }

    // Wrap it
    // Note: applyOnBatch returns dynamic Function()
    final wrapped =
        LevitStateMiddlewareChain.applyOnBatch(coreExecution, batchChange);
    return wrapped() as R;
  }

  /// Executes [callback] in an asynchronous batch.
  ///
  /// Changes are collected and passed to middleware hooks.
  /// Returns the result of [callback], or throws if a middleware cancels.
  static Future<R> batchAsync<R>(Future<R> Function() callback) async {
    if (!LevitReactiveMiddleware.hasBatchMiddlewares) {
      _batchDepth++;
      _coreState |= _stateBatchDepth;
      _fastPath = false;
      _enterAsyncScope();
      final batchSet = Set<LevitReactiveNotifier>.identity();
      try {
        return await runZoned(
          () => callback(),
          zoneValues: {_batchZoneKey: batchSet},
        );
      } finally {
        _exitAsyncScope();
        _batchDepth--;
        if (_batchDepth == 0) {
          _coreState &= ~_stateBatchDepth;
          _fastPath = _coreState == 0;
        }
        if (_batchDepth == 0) {
          _flushGlobalBatch();
        }
        for (final notifier in batchSet) {
          notifier.notify();
        }
      }
    }

    // Wrapped path
    final entries = <(LxReactive, LevitReactiveChange)>[];
    final batchChange = LevitReactiveBatch(entries);

    dynamic coreExecution() async {
      _batchDepth++;
      _coreState |= _stateBatchDepth;
      _fastPath = false;
      _enterAsyncScope();

      final batchSet = Set<LevitReactiveNotifier>.identity();
      try {
        return await runZoned(
          () => callback(),
          zoneValues: {
            _batchZoneKey: batchSet,
            _batchEntriesKey: entries,
          },
        );
      } finally {
        _exitAsyncScope();
        _batchDepth--;
        if (_batchDepth == 0) {
          _coreState &= ~_stateBatchDepth;
          _fastPath = _coreState == 0;
        }
        if (_batchDepth == 0) {
          _flushGlobalBatch();
        }
        for (final notifier in batchSet) {
          notifier.notify();
        }
      }
    }

    final wrapped =
        LevitStateMiddlewareChain.applyOnBatch(coreExecution, batchChange);
    return await (wrapped() as Future<dynamic>);
  }
}

/// The foundational interface for all reactive objects in the Levit ecosystem.
///
/// [LxReactive] unifies various reactive sources (variables, futures, streams)
/// under a consistent API. This allows components like [watch] and [LWatch]
/// to observe any reactive source interchangeably.
///
/// ### Core Responsibilities
/// 1.  **Observation**: Reports reads to the active [LevitReactiveObserver].
/// 2.  **Notification**: Alerts listeners and streams when the underlying value changes.
/// 3.  **Lifecycle**: Provides a mechanism for resource cleanup via [close].
abstract interface class LxReactive<T> {
  /// The current state of the reactive object.
  ///
  /// Reading this property automatically registers the object as a dependency
  /// for the active observer (e.g., inside an [LxComputed] or [LWatch] build).
  T get value;

  /// A unique runtime identifier for this reactive instance.
  int get id;

  /// A [Stream] that emits the latest value whenever it updates.
  Stream<T> get stream;

  /// Registers a synchronous [listener] to be called on every value update.
  void addListener(void Function() listener);

  /// Unregisters a previously added [listener].
  void removeListener(void Function() listener);

  /// Triggers a notification without changing the value.
  ///
  /// This ensures that all current listeners are notified of the current state,
  /// and any associated streams emit the latest value.
  void refresh();

  /// Permanently closes the reactive object and releases all internal resources.
  ///
  /// After calling [close], the object should no longer be used.
  void close();

  /// An optional descriptive name for debugging and profiling.
  String? get name;
  set name(String? value);

  /// The registration key of the owning controller, if applicable.
  String? get ownerId;
  set ownerId(String? value);
}

/// An observer interface used to automatically track reactive dependencies.
///
/// [LevitReactiveObserver] is implemented by components that need to respond
/// to changes in reactive state without manual subscription management.
///
/// ### Architectural Rationale
/// Manual subscription management (adding/removing listeners) is complex and
/// error-prone. By using a proxy-based observer, Levit enables "reactive-by-access"
/// patterns where dependencies are detected implicitly during execution.
abstract class LevitReactiveObserver {
  /// Internal: Registers a [LevitReactiveNotifier] dependency.
  void addNotifier(LevitReactiveNotifier notifier);

  /// Internal: Tracks the reactive source for dependency graph visualization.
  void addReactive(LxReactive reactive) {}
}

/// A low-latency notifier for synchronous reactive updates.
///
/// [LevitReactiveNotifier] is the high-performance core of the reactive system.
/// Unlike [StreamController], it provides zero-latency notifications through
/// synchronous callbacks and implements several optimizations for large-scale
/// reactive graphs.
///
/// ### Performance Optimizations
/// 1.  **Fast Path**: Direct call for single-listener, no-batch scenarios.
/// 2.  **Topological Ordering**: Derived values (like computeds) notify only
///     after their dependencies have updated, preventing "glitches".
/// 3.  **Deduplication**: Prevents duplicate propagation in complex "diamond"
///     dependency patterns.
/// 4.  **Zero-Allocation Snapshots**: Caches listener lists to avoid allocation
///     during notification cycles.
class LevitReactiveNotifier {
  void Function()? _singleListener;
  Set<void Function()>? _setListeners;
  List<void Function()>? _notifySnapshot;

  // Bitmask for flags
  int _flags = 0;
  static const int _flagDisposed = 1 << 0;
  static const int _flagPendingSyncBatch = 1 << 1;
  static const int _flagPendingPropagate = 1 << 2;
  static const int _flagIsActive = 1 << 3;

  bool get _disposed => (_flags & _flagDisposed) != 0;
  bool get _isPendingSyncBatch => (_flags & _flagPendingSyncBatch) != 0;
  bool get _isPendingPropagate => (_flags & _flagPendingPropagate) != 0;

  /// The distance of this notifier from the primary state sources.
  /// Used to ensure correct notification order.
  int _graphDepth = 0;

  /// Returns the current depth in the dependency graph.
  int get graphDepth => _graphDepth;

  LevitReactiveNotifier();

  /// Adds a listener.
  void addListener(void Function() listener) {
    if (_disposed) return;

    // Notify middleware if active
    if (LevitReactiveMiddleware.hasListenerMiddlewares && this is LxReactive) {
      LevitStateMiddlewareChain.applyOnListenerAdd(
          this as LxReactive, _LevitReactiveCore.listenerContext);
    }

    if (_singleListener == null && _setListeners == null) {
      _singleListener = listener;
      return;
    }

    if (_setListeners != null) {
      if (_setListeners!.add(listener)) {
        _notifySnapshot = null;
      }
      return;
    }

    if (_singleListener != null) {
      if (_singleListener == listener) return;
      _setListeners = {_singleListener!, listener};
      _singleListener = null;
      _notifySnapshot = null;
    }
  }

  /// Removes a listener.
  void removeListener(void Function() listener) {
    if (_disposed) return;

    // Notify middleware if active
    if (LevitReactiveMiddleware.hasListenerMiddlewares && this is LxReactive) {
      LevitStateMiddlewareChain.applyOnListenerRemove(
          this as LxReactive, _LevitReactiveCore.listenerContext);
    }

    if (_singleListener != null) {
      if (_singleListener == listener) {
        _singleListener = null;
      }
      return;
    }

    if (_setListeners != null) {
      if (_setListeners!.remove(listener)) {
        _notifySnapshot = null;
      }
      if (_setListeners!.isEmpty) {
        _setListeners = null;
        _notifySnapshot = null;
        // Optimization: Don't move back to single listener to avoid thrashing?
        // Or if empty, we are fine.
      }
    }
  }

  /// Notifies all listeners of a change.
  void notify() {
    final flags = _flags;
    if ((flags & _flagDisposed) != 0) return;

    final single = _singleListener;
    final multiple = _setListeners;

    // Ultra-fast path: No batching/observers/propagation AND common single-listener case
    if (_LevitReactiveCore._fastPath && single != null && multiple == null) {
      if (LevitReactiveMiddleware._hasErrorMiddlewares) {
        try {
          single();
        } catch (e, s) {
          LevitStateMiddlewareChain.applyOnReactiveError(
              e, s, this is LxReactive ? this as LxReactive : null);
        }
      } else {
        single();
      }
      return;
    }

    final coreState = _LevitReactiveCore._coreState;

    // 0. Handle Async Batching
    if ((coreState & _LevitReactiveCore._stateAsyncDepth) != 0) {
      final asyncBatch = Zone.current[_LevitReactiveCore._batchZoneKey];
      if (asyncBatch is Set<LevitReactiveNotifier>) {
        asyncBatch.add(this);
        return;
      }
    }

    // 1. Handle Sync Batching
    if ((coreState & _LevitReactiveCore._stateBatchDepth) != 0) {
      if (!_isPendingSyncBatch) {
        _flags |= _flagPendingSyncBatch;
        _LevitReactiveCore._batchedNotifiers.add(this);
      }
      return;
    }

    // 2. Handle Iterative Propagation
    if ((coreState & _LevitReactiveCore._statePropagating) != 0) {
      if (!_isPendingPropagate) {
        _flags |= _flagPendingPropagate;
        _LevitReactiveCore._propagationQueue.add(this);
      }
      return;
    }

    // 3. Start Propagation Cycle
    _LevitReactiveCore._coreState |= _LevitReactiveCore._statePropagating;
    _LevitReactiveCore._fastPath = false;

    try {
      _notifyListeners();

      final queue = _LevitReactiveCore._propagationQueue;
      if (queue.isNotEmpty) {
        var i = 0;
        while (i < queue.length) {
          final notifier = queue[i++];
          notifier._flags &= ~LevitReactiveNotifier._flagPendingPropagate;
          notifier._notifyListeners();
        }
        // If we finished successfully, clear immediately to avoid finally loop
        queue.clear();
      }
    } finally {
      // Re-check because a listener might have thrown but others need flag clearing
      final queue = _LevitReactiveCore._propagationQueue;
      if (queue.isNotEmpty) {
        for (var i = 0; i < queue.length; i++) {
          queue[i]._flags &= ~LevitReactiveNotifier._flagPendingPropagate;
        }
        queue.clear();
      }

      _LevitReactiveCore._coreState &= ~_LevitReactiveCore._statePropagating;
      _LevitReactiveCore._fastPath = _LevitReactiveCore._coreState == 0;
    }
  }

  void _notifyListeners() {
    final flags = _flags;
    if ((flags & _flagDisposed) != 0) return;

    final single = _singleListener;
    if (single != null) {
      if (!LevitReactiveMiddleware._hasErrorMiddlewares) {
        single();
        return;
      }
      try {
        single();
      } catch (e, s) {
        LevitStateMiddlewareChain.applyOnReactiveError(
            e, s, this is LxReactive ? this as LxReactive : null);
      }
      return;
    }

    // Multiple listeners path
    var snapshot = _notifySnapshot;
    if (snapshot == null) {
      final listeners = _setListeners;
      if (listeners == null || listeners.isEmpty) return;
      snapshot = listeners.toList(growable: false);
      _notifySnapshot = snapshot;
    }

    final length = snapshot.length;
    final hasErr = LevitReactiveMiddleware._hasErrorMiddlewares;

    // Optimized loop for common case (no error middleware)
    if (!hasErr) {
      for (var i = 0; i < length; i++) {
        // Skip disposal check in hot loop for maximum speed
        snapshot[i]();
      }
      return;
    }

    // Safe loop with error handling and disposal checks
    for (var i = 0; i < length; i++) {
      if ((_flags & _flagDisposed) != 0) break;
      try {
        snapshot[i]();
      } catch (e, s) {
        LevitStateMiddlewareChain.applyOnReactiveError(
            e, s, this is LxReactive ? this as LxReactive : null);
      }
    }
  }

  /// Disposed status
  bool get isDisposed => _disposed;

  void dispose() {
    _flags |= _flagDisposed;
    _singleListener = null;
    _setListeners = null;
  }

  /// Whether there are active listeners.
  bool get hasListener {
    return _singleListener != null ||
        (_setListeners != null && _setListeners!.isNotEmpty);
  }

  /// Set the depth (internal use only by computed values).
  @visibleForTesting
  set graphDepth(int value) => _graphDepth = value;
}

/// The primary implementation base for reactive objects.
///
/// [LxBase] provides the core mechanics for value storage, stream propagation,
/// and middleware integration. It combines the capabilities of [LevitReactiveNotifier]
/// and [LxReactive].
///
/// ### Key Features
/// 1.  **Value Storage**: Manages the underlying state and its transitions.
/// 2.  **Stream Integration**: Provides a broadcast [stream] of value changes
///     and supports [bind]ing to external data sources.
/// 3.  **Middleware Execution**: Wraps value mutations with interceptors for
///     logging, diagnostics, or state persistence.
/// 4.  **Automatic Observation**: Reports state access to the global proxy
///     to enable auto-tracking.
abstract class LxBase<T> extends LevitReactiveNotifier
    implements LxReactive<T> {
  static int _nextId = 0;

  @override
  final int id = _nextId++;

  @override
  String? name;

  /// Creates a reactive wrapper around [initial].
  LxBase(T initial, {this.onListen, this.onCancel, this.name})
      : _value = initial {
    if (LevitReactiveMiddleware.hasInitMiddlewares) {
      LevitStateMiddlewareChain.applyOnInit(this);
    }
  }

  T _value;
  StreamController<T>? _controller;
  // Removed _notifier field (this class is now the notifier)

  Stream<T>? _boundStream;
  int _externalListeners = 0;
  StreamSubscription<T>? _activeBoundSubscription;

  /// Called when the stream is listened to.
  final void Function()? onListen;

  /// Called when the stream is cancelled.
  final void Function()? onCancel;

  bool get _isActive => (_flags & LevitReactiveNotifier._flagIsActive) != 0;

  @override
  String? ownerId;

  void _protectedOnActive() {
    onListen?.call();
  }

  void _protectedOnInactive() {
    onCancel?.call();
  }

  void _checkActive() {
    final shouldBeActive = hasListener;
    if (shouldBeActive && !_isActive) {
      _flags |= LevitReactiveNotifier._flagIsActive;
      _protectedOnActive();
    } else if (!shouldBeActive && _isActive) {
      _flags &= ~LevitReactiveNotifier._flagIsActive;
      _protectedOnInactive();
    }
  }

  @override
  T get value {
    if (_LevitReactiveCore._fastPath) return _value;

    final proxy = _LevitReactiveCore.proxy;
    if (proxy != null) {
      _reportRead(proxy);
    } else if (_LevitReactiveCore._asyncZoneDepth > 0) {
      final zoneTracker =
          Zone.current[_LevitReactiveCore.asyncComputedTrackerZoneKey];
      if (zoneTracker is LevitReactiveObserver) {
        _reportRead(zoneTracker);
      }
    }
    return _value;
  }

  /// Notifies listeners without changing the value or triggering middlewares.
  ///
  /// Used by subclasses (like [LxComputed]) to propagate "dirty" state
  /// lazily without triggering a full value update cycle usually associated
  /// with middleware.
  // @protected
  void _notifyListenersOnly() {
    super.notify();
  }

  void _reportRead(LevitReactiveObserver observer) {
    if (identical(this, _LevitReactiveCore._lastReportedReactive) &&
        identical(observer, _LevitReactiveCore._lastReportedObserver)) {
      return;
    }

    _LevitReactiveCore._lastReportedObserver = observer;
    _LevitReactiveCore._lastReportedReactive = this;

    observer.addNotifier(this);

    // DevTools tracking: only enable if explicitly requested via middleware
    if (LevitReactiveMiddleware.hasGraphChangeMiddlewares) {
      observer.addReactive(this);
    }
  }

  /// Internal setter for subclasses (Computed, etc.)
  @visibleForTesting
  void setValueInternal(T val, {bool notifyListeners = true}) {
    // Fast Path (No Middleware)
    if (LevitReactiveMiddleware.bypassMiddleware ||
        !LevitReactiveMiddleware.hasSetMiddlewares) {
      if (_value == val) return;
      _value = val;
      _controller?.add(_value);
      if (notifyListeners) {
        super.notify();
      }
      return;
    }

    // Slow Path (Middleware / Interceptors)
    if (_value == val) return;

    final oldValue = _value;

    final change = LevitReactiveChange<T>(
      timestamp: DateTime.now(),
      valueType: T,
      oldValue: oldValue,
      newValue: val,
      stackTrace:
          _LevitReactiveCore.captureStackTrace ? StackTrace.current : null,
      restore: (v) {
        _value = v;
        _controller?.add(_value);
        if (notifyListeners) {
          super.notify();
        }
      },
    );

    // Core execution function
    void performSet(T v) {
      _value = v;
      _controller?.add(_value);
      if (notifyListeners) {
        super.notify();
      }
      // Record for batch
      if (_LevitReactiveCore.isBatching) {
        _LevitReactiveCore._recordBatchEntry(this, change);
      }
    }

    final wrapped =
        LevitStateMiddlewareChain.applyOnSet<T>(performSet, this, change);
    wrapped(val);
  }

  @override
  Stream<T> get stream {
    if (_boundStream != null) return _boundStream!;
    _controller ??= StreamController<T>.broadcast(
        onListen: () => _checkActive(), onCancel: () => _checkActive());
    return _controller!.stream;
  }

  /// Whether there are active listeners.
  @override
  bool get hasListener {
    // Discount our own internal subscription if present
    int effectiveExternal = _externalListeners;
    if (_activeBoundSubscription != null) effectiveExternal--;

    return (_controller?.hasListener ?? false) ||
        super.hasListener ||
        effectiveExternal > 0;
  }

  /// Whether there are active stream listeners.
  bool get _hasStreamListener {
    // Discount our own internal subscription if present
    int effectiveExternal = _externalListeners;
    if (_activeBoundSubscription != null) effectiveExternal--;

    return (_controller?.hasListener ?? false) || effectiveExternal > 0;
  }

  /// Binds an external stream to this reactive variable.
  void bind(Stream<T> externalStream) {
    if (_boundStream != null && _boundStream == externalStream) return;

    unbind();

    _boundStream = externalStream.map((event) {
      _value = event;
      _controller?.add(event);
      super.notify();
      return event;
    }).transform(
      StreamTransformer<T, T>.fromHandlers(
        handleError: (error, st, sink) {
          _controller?.addError(error, st);
          sink.addError(error, st);
        },
      ),
    ).asBroadcastStream(
      onListen: (sub) {
        _externalListeners++;
        _checkActive();
      },
      onCancel: (subscription) {
        _externalListeners--;
        _checkActive();
        subscription.cancel();
      },
    );

    if (hasListener) {
      _activeBoundSubscription = _boundStream!.listen((_) {});
    }
  }

  /// Unbinds any external stream.
  void unbind() {
    _activeBoundSubscription?.cancel();
    _activeBoundSubscription = null;
    _boundStream = null;
    _externalListeners = 0;
    _checkActive();
  }

  @override
  void close() {
    if (LevitReactiveMiddleware.bypassMiddleware ||
        !LevitReactiveMiddleware.hasDisposeMiddlewares) {
      unbind();
      _controller?.close();
      super.dispose();
      _checkActive();
    } else {
      final wrapped = LevitStateMiddlewareChain.applyOnDispose(() {
        unbind();
        _controller?.close();
        super.dispose();
        _checkActive();
      }, this);
      wrapped();
    }
  }

  /// Functor-like call to get value.
  T call() {
    // Return the current value
    return value;
  }

  /// Triggers a notification without changing the value.
  ///
  /// This also triggers middleware hooks to ensure mutations are tracked.
  void refresh() {
    // Fast Path
    if (LevitReactiveMiddleware.bypassMiddleware ||
        !LevitReactiveMiddleware.hasSetMiddlewares) {
      _controller?.add(_value);
      super.notify();
      return;
    }

    // Slow Path
    final change = LevitReactiveChange<T>(
      timestamp: DateTime.now(),
      valueType: T,
      oldValue: _value,
      newValue: _value,
      stackTrace:
          _LevitReactiveCore.captureStackTrace ? StackTrace.current : null,
      restore: (v) {
        _value = v;
        _controller?.add(_value);
        super.notify();
      },
    );

    void performRefresh(T v) {
      _controller?.add(
          v); // Uses v in case middleware modified it (unlikely for refresh but consistent)
      super.notify();
      if (_LevitReactiveCore.isBatching) {
        _LevitReactiveCore._recordBatchEntry(this, change);
      }
    }

    final wrapped =
        LevitStateMiddlewareChain.applyOnSet<T>(performRefresh, this, change);
    wrapped(_value);
  }

  /// Alias for [refresh].
  @override
  void notify() => refresh();

  /// Mutates the value in place and triggers a refresh.
  void mutate(void Function(T value) mutator) {
    mutator(_value);
    refresh();
  }

  @override
  void addListener(void Function() listener) {
    super.addListener(listener);
    _checkActive();

    if (_isActive && _boundStream != null && _activeBoundSubscription == null) {
      _activeBoundSubscription = _boundStream!.listen((_) {});
    }
  }

  @override
  void removeListener(void Function() listener) {
    super.removeListener(listener);
    _checkActive();

    if (!hasListener) {
      _activeBoundSubscription?.cancel();
      _activeBoundSubscription = null;
    }
  }

  /// Updates the value using a transformation function.
  void updateValue(T Function(T val) fn) {
    setValueInternal(fn(_value));
  }

  @override
  String toString() => _value.toString();

  /// Whether the reactive object has been closed/disposed.
  @override
  bool get isDisposed => super.isDisposed;
}

/// A standard context descriptor for reactive listeners.
///
/// Used to identify "who" is listening to a reactive variable.
class LxListenerContext {
  /// The string representation of the listener's runtime type.
  final String type;

  /// The identity hash code of the listener.
  final int id;

  /// Additional metadata or payload for the listener.
  final Object? data;

  /// Creates a standard listener context.
  const LxListenerContext({
    required this.type,
    required this.id,
    this.data,
  });

  /// Serializes the context to a JSON map.
  Map<String, dynamic> toJson() => {
        'type': type,
        'id': id,
        'data': data,
      };

  @override
  String toString() => 'LxContext(type: $type, id: $id, data: $data)';
}
